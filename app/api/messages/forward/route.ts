// ==========================================
// MESSAGE FORWARDING API - FACEBOOK MESSENGER STYLE
// ==========================================
// Forward messages to multiple conversations

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { z } from 'zod';
import { checkRateLimit } from '@/lib/cache';
import { publishEvent } from '@/lib/kafka';

const forwardMessageSchema = z.object({
  messageId: z.string().uuid(),
  targetConversationIds: z.array(z.string().uuid()).min(1).max(10),
  addComment: z.string().max(1000).optional(),
});

// POST /api/messages/forward - Forward a message to multiple conversations
export async function POST(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Rate limiting
    const rateLimit = await checkRateLimit(`forward:${session.user.id}`, 50, 3600); // 50/hour
    if (!rateLimit.allowed) {
      return NextResponse.json({ 
        error: 'Too many forwards',
        resetTime: rateLimit.resetTime
      }, { status: 429 });
    }

    const { messageId, targetConversationIds, addComment } = forwardMessageSchema.parse(await request.json());

    // Get the original message and verify access
    const originalMessage = await prisma.message.findFirst({
      where: {
        id: messageId,
        isDeleted: false,
        conversation: {
          participants: {
            some: {
              userId: session.user.id,
              isHidden: false,
            },
          },
        },
      },
      include: {
        conversation: {
          select: {
            title: true,
            type: true,
          },
        },
      },
    });

    if (!originalMessage) {
      return NextResponse.json({ error: 'Message not found or access denied' }, { status: 404 });
    }

    // Verify user is participant in all target conversations
    const targetConversations = await prisma.conversation.findMany({
      where: {
        id: { in: targetConversationIds },
        participants: {
          some: {
            userId: session.user.id,
            isHidden: false,
          },
        },
      },
    });

    if (targetConversations.length !== targetConversationIds.length) {
      return NextResponse.json({ error: 'Access denied to one or more target conversations' }, { status: 403 });
    }

    // Create forwarded messages
    const forwardedMessages = await Promise.all(
      targetConversationIds.map(async (conversationId) => {        // Create the forwarded message
        const forwardedMessage = await prisma.message.create({
          data: {
            conversationId,
            senderId: session.user.id,
            content: originalMessage.content,
            messageType: originalMessage.messageType,
            mediaUrls: originalMessage.mediaUrls,
            mediaMetadata: originalMessage.mediaMetadata as any, // Type assertion for Prisma JSON field
            // Mark as forwarded message
            isAutoGenerated: false,
            priority: 'NORMAL',
          },
        });

        // If user added a comment, create a separate message
        if (addComment?.trim()) {
          await prisma.message.create({
            data: {
              conversationId,
              senderId: session.user.id,
              content: addComment.trim(),
              messageType: 'TEXT',
              priority: 'NORMAL',
            },
          });
        }

        // Update conversation activity
        await prisma.conversation.update({
          where: { id: conversationId },
          data: { 
            lastActivity: new Date(),
            updatedAt: new Date(),
          },
        });

        // Publish real-time event
        try {
          await publishEvent('messages', {
            type: 'MESSAGE_FORWARDED',
            data: {
              ...forwardedMessage,
              originalMessageId: messageId,
              forwardedFrom: {
                conversationTitle: originalMessage.conversation.title,
                conversationType: originalMessage.conversation.type,
              },
            },
            metadata: {
              userId: session.user.id,
              conversationId,
              rooms: [`conversation:${conversationId}`],
            },
          });
        } catch (error) {
          console.warn('Failed to publish forward event:', error);
        }

        return {
          conversationId,
          messageId: forwardedMessage.id,
          forwardedAt: forwardedMessage.createdAt,
        };
      })
    );

    return NextResponse.json({
      success: true,
      forwardedTo: forwardedMessages,
      originalMessageId: messageId,
      totalForwarded: forwardedMessages.length,
    });

  } catch (error) {
    console.error('Forward message error:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}